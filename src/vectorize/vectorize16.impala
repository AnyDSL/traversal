type Real = simd[f32 * 16];
type Id = simd[i32 * 16];
type Intr = simd[bool * 16];

fn id(i: i32) -> Id {
    simd[i, i, i, i, i, i, i, i, i, i, i, i, i, i, i, i]
}

fn load_id(i: &i32) -> Id {
    *(i as &Id)
}

fn store_id(mut i: &i32, id: Id) -> () {
    *(i as &Id) = id
}

fn real(f: f32) -> Real {
    simd[f, f, f, f, f, f, f, f, f, f, f, f, f, f, f, f]
}

fn load_real(f: &f32) -> Real {
    *(f as &Real)
}

fn store_real(mut f: &f32, r: Real) -> () {
    *(f as &Real) = r
}

fn any(i: Intr) -> bool {
    i(0)  | i(1)  | i(2)  | i(3)  |
    i(4)  | i(5)  | i(6)  | i(7)  |
    i(8)  | i(9)  | i(10) | i(11) |
    i(12) | i(13) | i(14) | i(15)
}

fn all(i: Intr) -> bool {
    i(0)  & i(1)  & i(2)  & i(3)  &
    i(4)  & i(5)  & i(6)  & i(7)  &
    i(8)  & i(9)  & i(10) & i(11) &
    i(12) & i(13) & i(14) & i(15)
}

fn ballot(i: Intr) -> bool {
    let j = select16i32(i,
        simd[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
        simd[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);
    j(0) + j(1) + j(2)  + j(3)  + j(4)  + j(5)  + j(6)  + j(7) +
    j(8) + j(9) + j(10) + j(11) + j(12) + j(13) + j(14) + j(15) >= 8
}

fn mask_store_id(i: Intr, src: Id, mut dst: &Id) -> () {
    *dst = select16i32(i, src, *dst);
}

fn mask_store_real(i: Intr, src: Real, mut dst: &Real) -> () {
    *dst = select16f32(i, src, *dst);
}

fn min_real(a: Real, b: Real)-> Real @{
    select16f32(a < b, a, b)
}

fn max_real(a: Real, b: Real)-> Real @{
    select16f32(a > b, a, b)
}

static vector_size = 16;
