type Real = simd[f32 * 4];
type Id = simd[i32 * 4];
type Intr = simd[bool * 4];

fn id(i: i32) -> Id {
    simd[i, i, i, i]
}

fn load_id(i: &i32) -> Id {
    *(i as &Id)
}

fn store_id(mut i: &i32, id: Id) -> () {
    *(i as &Id) = id
}

fn real(f: f32) -> Real {
    simd[f, f, f, f]
}

fn load_real(f: &f32) -> Real {
    *(f as &Real)
}

fn store_real(mut f: &f32, r: Real) -> () {
    *(f as &Real) = r
}

fn any(i: Intr) -> bool {
    i(0) | i(1) | i(2) | i(3)
}

fn all(i: Intr) -> bool {
    i(0) & i(1) & i(2) & i(3)
}

fn ballot(i: Intr) -> bool {
    let j = select4i32(i, simd[1, 1, 1, 1], simd[0, 0, 0, 0]);
    j(0) + j(1) + j(2) + j(3) >= 2
}

fn mask_store_id(i: Intr, src: Id, mut dst: &Id) -> () {
    *dst = select4i32(i, src, *dst);
}

fn mask_store_real(i: Intr, src: Real, mut dst: &Real) -> () {
    *dst = select4f32(i, src, *dst);
}

fn min_real(a: Real, b: Real)-> Real @{
    select4f32(a < b, a, b)
}

fn max_real(a: Real, b: Real)-> Real @{
    select4f32(a > b, a, b)
}

static vector_size = 4;
