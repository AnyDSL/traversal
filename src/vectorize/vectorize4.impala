type Real = simd[f32 * 4];
type Id = simd[i32 * 4];
type Intr = simd[bool * 4];

fn id(i: i32) -> Id {
    simd[i, i, i, i]
}

fn set_id(mut id: &Id, i: i32, j: i32) -> () {
    id(i) = j
}

fn get_id(id: Id, i: i32) -> i32 {
    id(i)
}

fn real(f: f32) -> Real {
    simd[f, f, f, f]
}

fn set_real(mut r: &Real, i: i32, f: f32) -> () {
    r(i) = f;
}

fn get_real(r: Real, i: i32) -> f32 {
    r(i)
}

fn any(i: Intr) -> bool {
    i(0) | i(1) | i(2) | i(3)
}

fn all(i: Intr) -> bool {
    i(0) & i(1) & i(2) & i(3)
}

fn ballot(i: Intr) -> bool {
    let j = select4i32(i, simd[1, 1, 1, 1], simd[0, 0, 0, 0]);
    j(0) + j(1) + j(2) + j(3) >= 2
}

fn id_mask_store(i: Intr, src: Id, mut dst: &Id) -> () {
    *dst = select4i32(i, src, *dst);
}

fn real_mask_store(i: Intr, src: Real, mut dst: &Real) -> () {
    *dst = select4f32(i, src, *dst);
}

fn min_real(a: Real, b: Real)-> Real @{
    select4f32(a < b, a, b)
}

fn max_real(a: Real, b: Real)-> Real @{
    select4f32(a > b, a, b)
}

static vector_size = 4;
