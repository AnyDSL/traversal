// Mapping for GPU raytracing
static block_w = 32;
static block_h = 4;

type Real = f32;
type Mask = bool;
type Intr = i32;
type HitFn = fn (Intr, Real, Real, Real) -> ();

fn select_real(m: Mask, a: Real, b: Real) -> Real { if m { a } else { b } }
fn select_intr(m: Mask, a: Intr, b: Intr) -> Intr { if m { a } else { b } }
fn real(x: f32) -> Real { x }
fn intr(x: i32) -> Intr { x }

fn any(m: Mask) -> bool { m }
fn all(m: Mask) -> bool { m }
fn abs_real(r: Real) -> Real { fabsf(r) }

extern "C" {
    fn min_real(Real, Real) -> Real;
    fn max_real(Real, Real) -> Real;
    fn minmin_real(Real, Real, Real) -> Real;
    fn maxmax_real(Real, Real, Real) -> Real;
    fn minmax_real(Real, Real, Real) -> Real;
    fn maxmin_real(Real, Real, Real) -> Real;
    fn ldg4f(&simd[f32 * 4]) -> simd[f32 * 4];
    fn ldg4i(&simd[i32 * 4]) -> simd[i32 * 4];
    fn float_as_int(f32) -> i32;
}

struct BBox {
    lo_x: f32,
    hi_x: f32,
    lo_y: f32,
    hi_y: f32,
    lo_z: f32,
    hi_z: f32
}

struct Node {
    left_bb: BBox,
    right_bb: BBox,
    left: i32,
    right: i32,
    pad0: i32,
    pad1: i32
}

fn iterate_triangles(nodes: &[Node], node_id: i32, mut tris: &[Vec4], body: fn (i32, Vec3, Vec3, Vec3) -> ()) -> () {
    let mut loop_id = !node_id;
    while true {
        let v0 = *(&tris(loop_id + 0) as &simd[f32 * 4]);
        let v1 = *(&tris(loop_id + 1) as &simd[f32 * 4]);
        let v2 = *(&tris(loop_id + 2) as &simd[f32 * 4]);

        body(loop_id,
             vec3(v0(0), v0(1), v0(2)),
             vec3(v1(0), v1(1), v1(2)),
             vec3(v2(0), v2(1), v2(2)));

        if float_as_int(v2(3)) == 0x80000000 {
            break()
        }

        loop_id += 3;
    }
}

fn iterate_children(mut nodes: &[Node], node_id: i32, stack: Stack, body: fn(Vec3, Vec3, fn (bool, f32) -> ()) -> ()) -> () {
    let mut node_ptr = &nodes(node_id) as &[f32];
    let bb0 = ldg4f(&node_ptr(0) as &simd[f32 * 4]);
    let bb1 = ldg4f(&node_ptr(4) as &simd[f32 * 4]);
    let bb2 = ldg4f(&node_ptr(8) as &simd[f32 * 4]);
    let mut children = ldg4i(&node_ptr(12) as &simd[i32 * 4]);

    body(vec3(bb0(0), bb0(2), bb1(0)), vec3(bb0(1), bb0(3), bb1(1)), |hit0, t0| {
        body(vec3(bb1(2), bb2(0), bb2(2)), vec3(bb1(3), bb2(1), bb2(3)), |hit1, t1| {
            if !hit0 && !hit1 {
                stack.pop();
            } else {
                if hit0 && hit1 {
                    if t0 < t1 {
                        children(0) ^= children(1);
                        children(1) ^= children(0);
                        children(0) ^= children(1);
                    }
                    stack.push(|i| { children(i) }, 2)
                } else {
                    stack.push(|i| { if hit0 { children(0) } else { children(1) } }, 1)
                }
            }
        });
    });  
}

fn iterate_rays(mut rays: &[Ray], mut hits: &[Hit], ray_count: i32, body: fn (Vec3, Vec3, f32, f32, HitFn) -> ()) -> () {
    let dev = acc_dev();
    let grid = (ray_count / block_h, block_h, 1);
    let block = (block_w, block_h, 1);

    acc(dev, grid, block, |exit| {
        let id = acc_tidx() + acc_bdimx() * (acc_tidy() + acc_bdimy() * (acc_bidx() + acc_gdimx() * acc_bidy()));
        if id > ray_count {
            exit()
        }

        let mut ray_ptr = &rays(id) as &[f32];
        let ray0 = ldg4f(&ray_ptr(0) as &simd[f32 * 4]);
        let ray1 = ldg4f(&ray_ptr(4) as &simd[f32 * 4]);

        @body(vec3(ray0(0), ray0(1), ray0(2)),
              vec3(ray1(0), ray1(1), ray1(2)),
              ray0(3), ray1(3), |tri, t, u, v| {
            *(&hits(id) as &simd[i32 * 4]) = simd[tri, float_as_int(t), float_as_int(u), float_as_int(v)];
        });
    })
}
