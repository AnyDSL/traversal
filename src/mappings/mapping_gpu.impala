// Mapping for GPU raytracing
static block_w = 32;
static block_h = 4;

type Real = f32;
type Mask = bool;
type Intr = i32;
type HitFn = fn (Intr, Real, Real, Real) -> ();

fn select_real(m: Mask, a: Real, b: Real) -> Real { if m { a } else { b } }
fn select_intr(m: Mask, a: Intr, b: Intr) -> Intr { if m { a } else { b } }
fn real(x: f32) -> Real { x }
fn intr(x: i32) -> Intr { x }

fn any(m: Mask) -> bool { m }
fn all(m: Mask) -> bool { m }
fn abs_real(r: Real) -> Real { fabsf(r) }
fn min_real(a: Real, b: Real) -> Real { fminf(a, b) }
fn max_real(a: Real, b: Real) -> Real { fmaxf(a, b) }
fn minmin_real(a: Real, b: Real, c: Real) -> Real { bitcast_i32_f32(minmin(bitcast_f32_i32(a), bitcast_f32_i32(b), bitcast_f32_i32(c))) }
fn maxmax_real(a: Real, b: Real, c: Real) -> Real { bitcast_i32_f32(maxmax(bitcast_f32_i32(a), bitcast_f32_i32(b), bitcast_f32_i32(c))) }
fn minmax_real(a: Real, b: Real, c: Real) -> Real { bitcast_i32_f32(minmax(bitcast_f32_i32(a), bitcast_f32_i32(b), bitcast_f32_i32(c))) }
fn maxmin_real(a: Real, b: Real, c: Real) -> Real { bitcast_i32_f32(maxmin(bitcast_f32_i32(a), bitcast_f32_i32(b), bitcast_f32_i32(c))) }

struct BBox {
    lo_x: f32,
    hi_x: f32,
    lo_y: f32,
    hi_y: f32,
    lo_z: f32,
    hi_z: f32
}

struct Node {
    left_bb: BBox,
    right_bb: BBox,
    left: i32,
    right: i32,
    pad0: i32,
    pad1: i32
}

fn iterate_triangles(nodes: &[Node], node_id: i32, mut tris: &[Vec4], body: fn (i32, Vec3, Vec3, Vec3) -> ()) -> () {
    let mut loop_id = !node_id;
    while true {
        let v0 = *(&tris(loop_id + 0) as &simd[f32 * 4]);
        let v1 = *(&tris(loop_id + 1) as &simd[f32 * 4]);
        let v2 = *(&tris(loop_id + 2) as &simd[f32 * 4]);

        body(loop_id,
             vec3(v0(0), v0(1), v0(2)),
             vec3(v1(0), v1(1), v1(2)),
             vec3(v2(0), v2(1), v2(2)));

        if bitcast_f32_i32(v2(3)) == 0x80000000 {
            break()
        }

        loop_id += 3;
    }
}

fn iterate_children(mut nodes: &[Node], node_id: i32, stack: Stack, body: fn(Vec3, Vec3, fn (f32, f32) -> ()) -> ()) -> () {
    let mut node_ptr = &nodes(node_id) as &[f32];
    let bb0 = ldg4_f32(&node_ptr(0) as &simd[f32 * 4]);
    let bb1 = ldg4_f32(&node_ptr(4) as &simd[f32 * 4]);
    let bb2 = ldg4_f32(&node_ptr(8) as &simd[f32 * 4]);
    let mut children = ldg4_i32(&node_ptr(12) as &simd[i32 * 4]);

    body(vec3(bb0(0), bb0(2), bb1(0)), vec3(bb0(1), bb0(3), bb1(1)), |t00, t01| {
        body(vec3(bb1(2), bb2(0), bb2(2)), vec3(bb1(3), bb2(1), bb2(3)), |t10, t11| {
            let hit0 = t00 <= t01;
            let hit1 = t10 <= t11;
            if !hit0 && !hit1 {
                stack.pop();
            } else {
                if hit0 && hit1 {
                    if t00 < t10 {
                        children(0) ^= children(1);
                        children(1) ^= children(0);
                        children(0) ^= children(1);
                    }
                    stack.push(|i| { children(i) }, 2)
                } else {
                    stack.push(|i| { if hit0 { children(0) } else { children(1) } }, 1)
                }
            }
        });
    });
}

fn iterate_rays(mut rays: &[Ray], mut hits: &[Hit], ray_count: i32, body: fn (Vec3, Vec3, f32, f32, HitFn) -> ()) -> () {
    let dev = acc_dev();
    let grid = (ray_count / block_h, block_h, 1);
    let block = (block_w, block_h, 1);

    acc(dev, grid, block, |exit| {
        let id = acc_tidx() + acc_bdimx() * (acc_tidy() + acc_bdimy() * (acc_bidx() + acc_gdimx() * acc_bidy()));
        if id > ray_count {
            exit()
        }

        let mut ray_ptr = &rays(id) as &[f32];
        let ray0 = ldg4_f32(&ray_ptr(0) as &simd[f32 * 4]);
        let ray1 = ldg4_f32(&ray_ptr(4) as &simd[f32 * 4]);

        @body(vec3(ray0(0), ray0(1), ray0(2)),
              vec3(ray1(0), ray1(1), ray1(2)),
              ray0(3), ray1(3), |tri, t, u, v| {
            *(&hits(id) as &simd[f32 * 4]) = simd[bitcast_i32_f32(tri), t, u, v];
        });
    })
}
