// Mapping for GPU raytracing
static block_w = 32;
static block_h = 4;

type Real = f32;
type Mask = bool;
type Intr = i32;
type HitFn = fn (Intr, Real) -> ();

fn mstore_real(m: Mask, mut dst: &Real, src: Real) -> () { if m { *dst = src; } }
fn mstore_intr(m: Mask, mut dst: &Intr, src: Intr) -> () { if m { *dst = src; } }
fn real(x: f32) -> Real { x }
fn intr(x: i32) -> Intr { x }

fn any(m: Mask) -> bool { m }
fn all(m: Mask) -> bool { m }
fn abs_real(r: Real) -> Real { fabsf(r) }

extern "C" {
    fn min_real(Real, Real) -> Real;
    fn max_real(Real, Real) -> Real;
    fn minmin_real(Real, Real, Real) -> Real;
    fn maxmax_real(Real, Real, Real) -> Real;
    fn minmax_real(Real, Real, Real) -> Real;
    fn maxmin_real(Real, Real, Real) -> Real;
    fn ldg4f(&simd[f32 * 4]) -> simd[f32 * 4];
    fn ldg4i(&simd[i32 * 4]) -> simd[i32 * 4];
}

struct BBox {
    lo_x: f32,
    hi_x: f32,
    lo_y: f32,
    hi_y: f32,
    lo_z: f32,
    hi_z: f32
}

struct Node {
    left_bb: BBox,
    right_bb: BBox,
    left: i32,
    right: i32,
    pad0: i32,
    pad1: i32
}

struct Hit {
    tri_id: i32,
    tmax: f32,
    pad0: i32,
    pad1: i32
}

fn iterate_triangles(nodes: &[Node], mut tris: &[Vec4], node_id: i32, body: fn (i32, Vec3, Vec3, Vec3) -> ()) -> () {
    let mut loop_id = !node_id;
    while true {
        let v0 = *(&tris(loop_id + 0) as &simd[f32 * 4]);
        let v1 = *(&tris(loop_id + 1) as &simd[f32 * 4]);
        let v2 = *(&tris(loop_id + 2) as &simd[f32 * 4]);

        body(loop_id,
             vec3(v0(0), v0(1), v0(2)),
             vec3(v1(0), v1(1), v1(2)),
             vec3(v2(0), v2(1), v2(2)));

        loop_id += 3;
        if tris(loop_id).x == -0.0f {
            break()
        }
    }
}

fn iterate_children(mut nodes: &[Node], stack: &Stack, mut node_id: &i32, body: fn(Vec3, Vec3, fn (bool, f32) -> ()) -> ()) -> () {
    let mut node_ptr = &nodes(*node_id) as &[f32];
    let bb0 = ldg4f(&node_ptr(0) as &simd[f32 * 4]);
    let bb1 = ldg4f(&node_ptr(4) as &simd[f32 * 4]);
    let bb2 = ldg4f(&node_ptr(8) as &simd[f32 * 4]);
    let children = ldg4i(&node_ptr(12) as &simd[i32 * 4]);

    let mut t : [f32 * 2];
    let mut next : [i32 * 2];
    let mut intr : [bool * 2] = [false, false];

    body(vec3(bb0(0), bb0(2), bb1(0)), vec3(bb0(1), bb0(3), bb1(1)), |hit, t0| {
        t(0) = t0;
        next(0) = children(0);
        intr(0) = hit;
    });

    body(vec3(bb1(2), bb2(0), bb2(2)), vec3(bb1(3), bb2(1), bb2(3)), |hit, t0| {
        t(1) = t0;
        next(1) = children(1);
        intr(1) = hit;
    });

    if !intr(0) && !intr(1) {
        // Pop from the stack
        *node_id = pop(stack);
    } else {
        *node_id = if intr(0) { next(0) } else { next(1) };
        if intr(0) && intr(1) {
            push(stack, if t(1) < t(0) { *node_id = next(1); next(0) } else { next(1) });
        }
    }
}

fn iterate_rays(mut rays: &[Ray], mut hits: &[Hit], ray_count: i32, body: fn (Vec3, Vec3, f32, f32, HitFn) -> ()) -> () {
    let dev = acc_dev();
    let grid = (ray_count / block_h, block_h, 1);
    let block = (block_w, block_h, 1);

    acc(dev, grid, block, |exit| {
        let id = acc_tidx() + acc_bdimx() * (acc_tidy() + acc_bdimy() * (acc_bidx() + acc_gdimx() * acc_bidy()));
        if id > ray_count {
            exit()
        }

        let mut ray_ptr = &rays(id) as &[f32];
        let ray0 = ldg4f(&ray_ptr(0) as &simd[f32 * 4]);
        let ray1 = ldg4f(&ray_ptr(4) as &simd[f32 * 4]);

        @body(vec3(ray0(0), ray0(1), ray0(2)),
              vec3(ray1(0), ray1(1), ray1(2)),
              ray0(3), ray1(3), |tri, t| {
            if tri >= 0{
                hits(id).tri_id = tri;
                hits(id).tmax = t;
            }
        });
    })
}
