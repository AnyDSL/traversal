// Mapping for packet tracing on the CPU
static vector_size = 8;

type Real = simd[f32 * 8];
type Mask = simd[f32 * 8];
type Intr = simd[i32 * 8];
type HitFn = fn (Intr, Real, Real, Real) -> ();

fn real(x: f32) -> Real { simd[x, x, x, x, x, x, x, x] }
fn intr(x: i32) -> Intr { simd[x, x, x, x, x, x, x, x] }

fn terminated(a: Intr) -> bool { movmskps256(bitcast[simd[i32 * 8],simd[f32 * 8]](a)) == 0 }
fn any(m: Mask) -> bool { movmskps256(m) != 0 }
fn all(m: Mask) -> bool { movmskps256(m) == 0xFF }
fn and(a: Mask, b: Mask) -> Mask { bitcast[simd[i32 * 8],simd[f32 * 8]](bitcast[simd[f32 * 8],simd[i32 * 8]](a) & bitcast[simd[f32 * 8],simd[i32 * 8]](b)) }
fn greater_eq(a: Real, b: Real) -> Mask { cmpps256(b, a, 2i8) }
fn greater(a: Real, b: Real) -> Mask    { cmpps256(b, a, 1i8) }
fn not_eq(a: Real, b: Real) -> Mask     { cmpps256(b, a, 4i8) }
fn select_real(m: Mask, a: Real, b: Real) -> Real { blendvps256(b, a, m) }
fn select_intr(m: Mask, a: Intr, b: Intr) -> Intr { bitcast[simd[f32 * 8],simd[i32 * 8]](blendvps256(bitcast[simd[i32 * 8],simd[f32 * 8]](b), bitcast[simd[i32 * 8],simd[f32 * 8]](a), m)) }

fn abs_real(x: Real) -> Real { bitcast[simd[i32 * 8],simd[f32 * 8]](bitcast[simd[f32 * 8],simd[i32 * 8]](x) & intr(0x7FFFFFFF)) }
fn rcp_real(x: Real) -> Real {
    let r = rcpps256(x);
    r * (real(2.0f) - x * r)
}
fn safe_rcp(x: Real) -> Real {
    let sign_max = bitcast[simd[i32 * 8],simd[f32 * 8]](bitcast[simd[f32 * 8],simd[i32 * 8]](real(flt_max)) | (bitcast[simd[f32 * 8],simd[i32 * 8]](x) & intr(0x80000000)));
    blendvps256(sign_max, rcp_real(x), not_eq(x, real(0.0f)))
}
fn prodsign_real(x: Real, y: Real) -> Real { bitcast[simd[i32 * 8],simd[f32 * 8]](bitcast[simd[f32 * 8],simd[i32 * 8]](x) ^ (bitcast[simd[f32 * 8],simd[i32 * 8]](y) & intr(0x80000000))) }

// Use integer instructions for min/max
fn min_real(a: Real, b: Real) -> Real { bitcast[simd[i32 * 8],simd[f32 * 8]](select[simd[bool * 8],simd[i32 * 8]](bitcast[simd[f32 * 8],simd[i32 * 8]](a) < bitcast[simd[f32 * 8],simd[i32 * 8]](b), bitcast[simd[f32 * 8],simd[i32 * 8]](a), bitcast[simd[f32 * 8],simd[i32 * 8]](b))) }
fn max_real(a: Real, b: Real) -> Real { bitcast[simd[i32 * 8],simd[f32 * 8]](select[simd[bool * 8],simd[i32 * 8]](bitcast[simd[f32 * 8],simd[i32 * 8]](a) > bitcast[simd[f32 * 8],simd[i32 * 8]](b), bitcast[simd[f32 * 8],simd[i32 * 8]](a), bitcast[simd[f32 * 8],simd[i32 * 8]](b))) }
fn minmin_real(a: Real, b: Real, c: Real) -> Real { min_real(min_real(a, b), c) }
fn maxmax_real(a: Real, b: Real, c: Real) -> Real { max_real(max_real(a, b), c) }
fn minmax_real(a: Real, b: Real, c: Real) -> Real { max_real(min_real(a, b), c) }
fn maxmin_real(a: Real, b: Real, c: Real) -> Real { min_real(max_real(a, b), c) }

struct Node {
    min_x: [f32 * 4], min_y: [f32 * 4], min_z: [f32 * 4],
    max_x: [f32 * 4], max_y: [f32 * 4], max_z: [f32 * 4],
    children: [i32 * 4]
}

fn iterate_triangles(nodes: &[Node], mut tris: &[Vec4]) -> IterateTrianglesFn {
    |t, stack, body, return| {
        // Cull this leaf if it is too far away
        if all(greater_eq(stack.tmin(), t)) { return() }

        let mut tri_id = !stack.top();
        while true {
            let tri_data = &tris(tri_id) as &[float];

            for i in @unroll(0, 4) {
                let id = bitcast[f32,i32](tri_data(48 + i));

                let v0 = vec3(real(tri_data( 0 + i)), real(tri_data( 4 + i)), real(tri_data( 8 + i)));
                let e1 = vec3(real(tri_data(12 + i)), real(tri_data(16 + i)), real(tri_data(20 + i)));
                let e2 = vec3(real(tri_data(24 + i)), real(tri_data(28 + i)), real(tri_data(32 + i)));
                let n  = vec3(real(tri_data(36 + i)), real(tri_data(40 + i)), real(tri_data(44 + i)));
                let tri = Tri {
                    v0: || { v0 },
                    e1: || { e1 },
                    e2: || { e2 },
                    n:  || { n }
                };

                body(tri, intr(id));
            }

            if bitcast[f32,i32](tri_data(52)) == 0x80000000 {
                break()
            }

            tri_id += 13;
        }
    }
}

fn iterate_children(nodes: &[Node]) -> IterateChildrenFn {
    |t, stack, body, return| {
        let node = nodes(stack.top());
        let tmin = stack.tmin();
        stack.pop();

        // Cull this node if it is too far away
        if all(greater_eq(tmin, t)) { return() }

        for i in @unroll(0, 4) {
            if node.children(i) == 0 { break() }

            let box = Box {
                min: || { vec3(real(node.min_x(i)), real(node.min_y(i)), real(node.min_z(i))) },
                max: || { vec3(real(node.max_x(i)), real(node.max_y(i)), real(node.max_z(i))) }
            };

            body(box, |t0, t1| {
                let t = select_real(greater_eq(t1, t0), t0, real(flt_max));
                if any(greater_eq(t1, t0)) {
                    if any(greater(stack.tmin(), t)) {
                        stack.push_top(node.children(i), t)
                    } else {
                        stack.push(node.children(i), t)
                    }
                }
            });
        }
    }
}

fn iterate_rays(rays: &[Ray], mut hits: &[Hit]) -> IterateRaysFn {
    |ray_count, body| {
        assert(|| { ray_count % vector_size == 0 }, "iterate_rays: number of rays must be a multiple of vector size");

        for j in $parallel(0, 0, ray_count / vector_size) {
            for i in range_step(j * vector_size, (j + 1) * vector_size, vector_size) @{
                let org = vec3(simd[rays(i + 0).org.x, rays(i + 1).org.x, rays(i + 2).org.x, rays(i + 3).org.x, rays(i + 4).org.x, rays(i + 5).org.x, rays(i + 6).org.x, rays(i + 7).org.x],
                               simd[rays(i + 0).org.y, rays(i + 1).org.y, rays(i + 2).org.y, rays(i + 3).org.y, rays(i + 4).org.y, rays(i + 5).org.y, rays(i + 6).org.y, rays(i + 7).org.y],
                               simd[rays(i + 0).org.z, rays(i + 1).org.z, rays(i + 2).org.z, rays(i + 3).org.z, rays(i + 4).org.z, rays(i + 5).org.z, rays(i + 6).org.z, rays(i + 7).org.z]);
                let dir = vec3(simd[rays(i + 0).dir.x, rays(i + 1).dir.x, rays(i + 2).dir.x, rays(i + 3).dir.x, rays(i + 4).dir.x, rays(i + 5).dir.x, rays(i + 6).dir.x, rays(i + 7).dir.x],
                               simd[rays(i + 0).dir.y, rays(i + 1).dir.y, rays(i + 2).dir.y, rays(i + 3).dir.y, rays(i + 4).dir.y, rays(i + 5).dir.y, rays(i + 6).dir.y, rays(i + 7).dir.y],
                               simd[rays(i + 0).dir.z, rays(i + 1).dir.z, rays(i + 2).dir.z, rays(i + 3).dir.z, rays(i + 4).dir.z, rays(i + 5).dir.z, rays(i + 6).dir.z, rays(i + 7).dir.z]);
                let tmin = simd[rays(i + 0).org.w, rays(i + 1).org.w, rays(i + 2).org.w, rays(i + 3).org.w, rays(i + 4).org.w, rays(i + 5).org.w, rays(i + 6).org.w, rays(i + 7).org.w];
                let tmax = simd[rays(i + 0).dir.w, rays(i + 1).dir.w, rays(i + 2).dir.w, rays(i + 3).dir.w, rays(i + 4).dir.w, rays(i + 5).dir.w, rays(i + 6).dir.w, rays(i + 7).dir.w];

                body(org, dir, tmin, tmax, |tri, t, u, v| {
                    for j in @unroll(0, vector_size) {
                        hits(i + j).tri_id = tri(j);
                        hits(i + j).tmax = t(j);
                        hits(i + j).u = u(j);
                        hits(i + j).v = v(j);
                    }
                });
            }
        }
    }
}

fn transparency(mut indices: &[i32], texcoords: &[Vec2], masks: &[TransparencyMask], mask_buf: &[i8]) -> TransparencyFn {
    |mask, tri_id, u, v| {
        let mut bit_mask = movmskps256(mask);
        let mut transp = bitcast[simd[f32 * 8],simd[i32 * 8]](mask);
        let w = real(1.0f) - u - v;
        for i in @unroll(0, vector_size) {
            if (bit_mask & 1) != 0 {
                let tri = *(&indices(tri_id(i) * 4) as &simd[i32 * 4]);
                let uv0 = texcoords(tri(0));
                let uv1 = texcoords(tri(1));
                let uv2 = texcoords(tri(2));

                let tu = uv0.x * w(i) + uv1.x * u(i) + uv2.x * v(i);
                let tv = uv0.y * w(i) + uv1.y * u(i) + uv2.y * v(i);

                let m = $lookup_mask(masks(tri(3)), mask_buf, tu, tv);

                transp(i) = if m { -1 } else { 0 }
            }
            bit_mask = bit_mask >> 1;
        }
        bitcast[simd[i32 * 8],simd[f32 * 8]](transp)
    }
}

extern fn intersect_cpu(nodes: &[Node], tris: &[Vec4], rays: &[Ray], hits: &[Hit], ray_count: i32) -> () {
    traverse(iterate_rays(rays, hits),
             iterate_children(nodes),
             iterate_triangles(nodes, tris),
             no_transparency,
             ray_count, false)
}

extern fn occluded_cpu(nodes: &[Node], tris: &[Vec4], rays: &[Ray], hits: &[Hit], ray_count: i32) -> () {
    traverse(iterate_rays(rays, hits),
             iterate_children(nodes),
             iterate_triangles(nodes, tris),
             no_transparency,
             ray_count, true)
}

extern fn intersect_masked_cpu(nodes: &[Node], tris: &[Vec4], rays: &[Ray], hits: &[Hit],
                               indices: &[i32], texcoords: &[Vec2], masks: &[TransparencyMask], mask_buf: &[i8], ray_count: i32) -> () {
    traverse(iterate_rays(rays, hits),
             iterate_children(nodes),
             iterate_triangles(nodes, tris),
             transparency(indices, texcoords, masks, mask_buf),
             ray_count, false)
}

extern fn occluded_masked_cpu(nodes: &[Node], tris: &[Vec4], rays: &[Ray], hits: &[Hit],
                              indices: &[i32], texcoords: &[Vec2], masks: &[TransparencyMask], mask_buf: &[i8], ray_count: i32) -> () {
    traverse(iterate_rays(rays, hits),
             iterate_children(nodes),
             iterate_triangles(nodes, tris),
             transparency(indices, texcoords, masks, mask_buf),
             ray_count, true)
}
