// Mapping for packet tracing on the CPU
struct RayPacket {
    org: Vec3,
    dir: Vec3,
    inv: Vec3,
    tri: Id,
    tmin: Real,
    tmax: Real,
    u: Real,
    v: Real
}

static postpone_count = 0;

fn iterate_rays(mut rays: Rays, i: i32, j: i32, body: fn(&RayPacket) -> ()) -> () {
    assert(|| {(j - i) % vector_size == 0}, "iterate_rays : invalid number of rays");

    for k in range_step(i, j, vector_size) {
        // Build a packet of rays of size 8 from the array
        let mut packet : RayPacket;

        packet.org.x = load_real(&rays.org_x(k));
        packet.org.y = load_real(&rays.org_y(k));
        packet.org.z = load_real(&rays.org_z(k));

        packet.dir.x = load_real(&rays.dir_x(k));
        packet.dir.y = load_real(&rays.dir_y(k));
        packet.dir.z = load_real(&rays.dir_z(k));

        packet.inv.x = real(1.0f) / packet.dir.x;
        packet.inv.y = real(1.0f) / packet.dir.y;
        packet.inv.z = real(1.0f) / packet.dir.z;

        packet.tri = load_id(&rays.tri(k));

        packet.tmin = load_real(&rays.tmin(k));
        packet.tmax = load_real(&rays.tmax(k));
        packet.u = load_real(&rays.u(k));
        packet.v = load_real(&rays.v(k));

        // Traverse the BVH
        body(&packet);

        // Write results back to the array
        store_id(&rays.tri(k), packet.tri);
        store_real(&rays.tmax(k), packet.tmax);
        store_real(&rays.u(k), packet.u);
        store_real(&rays.v(k), packet.v);
    }
}

fn intersect_leaf(mut packet: &RayPacket, accel: Accel, node: i32) -> () {
    // Test each ray of the packet against each triangle of the node
    for tri, v0, v1, v2 in iterate_triangles(accel, node) {
        intersect_ray_tri(packet.org, packet.dir, v0, v1, v2,
            |t, u, v, intr| {
                let mask = intr & t < packet.tmax & t > packet.tmin;
                mask_store_id(mask, id(tri), &packet.tri);
                mask_store_real(mask, t, &packet.tmax);
                mask_store_real(mask, u, &packet.u);
                mask_store_real(mask, v, &packet.v);
                continue()
            })
    }
}

fn intersect_node(packet: &RayPacket, accel: Accel, node: i32, stack: &Stack) -> () {
    // Intersect the children of this node
    for min, max, push in iterate_children(accel, node, stack) {
        intersect_ray_box(packet.org, packet.inv, min, max, |t_entry, t_exit, mask| {
            if any(mask & packet.tmin < t_exit & packet.tmax > t_entry) {
                push(t_entry)
            }
            continue()
        })
    }
}
