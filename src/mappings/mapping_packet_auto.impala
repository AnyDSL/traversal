// Mapping for packet tracing on the CPU using the vectorizer
struct RayPacket {
    org: [float * 24],
    dir: [float * 24],
    inv: [float * 24],
    tri: [int * 8],
    tmin: [float * 8],
    tmax: [float * 8],
    u: [float * 8],
    v: [float * 8]
}

static postpone_count = 0;

fn iterate_rays(mut rays: &[Ray], i: i32, j: i32, body: fn(&RayPacket) -> ()) -> () {
    assert(|| {(j - i) % 8 == 0}, "iterate_rays : invalid number of rays");

    for k in range_step(i, j, 8) {
        // Build a packet of rays of size 8 from the array
        let mut packet : RayPacket;

        for c in range(0, 8) {
            packet.org(0  + c) = rays(k + c).org(0);
            packet.org(8  + c) = rays(k + c).org(1);
            packet.org(16 + c) = rays(k + c).org(2);

            packet.dir(0  + c) = rays(k + c).dir(0);
            packet.dir(8  + c) = rays(k + c).dir(1);
            packet.dir(16 + c) = rays(k + c).dir(2);

            packet.inv(0  + c) = 1.0f / packet.dir(0  + c);
            packet.inv(8  + c) = 1.0f / packet.dir(8  + c);
            packet.inv(16 + c) = 1.0f / packet.dir(16 + c);

            packet.tri(c) = rays(k + c).tri;
            packet.tmin(c) = rays(k + c).tmin;
            packet.tmax(c) = rays(k + c).tmax;
            packet.u(c) = rays(k + c).u;
            packet.v(c) = rays(k + c).v;
        }

        // Traverse the BVH
        body(&packet);

        // Write results back to the array
        for c in range(0, vector_size) {
            rays(k + c).tri = packet.tri(c);
            rays(k + c).tmax = packet.tmax(c);
            rays(k + c).u = packet.u(c);
            rays(k + c).v = packet.v(c);
        }
    }
}

fn intersect_leaf(mut packet: &RayPacket, accel: Accel, node: i32) -> () {
    // Test each ray of the packet against each triangle of the node
    for tri, v0, v1, v2 in iterate_triangles(accel, node) {
        for i in vectorize(8, 0, 8) @{
            intersect_ray_tri(Vec3 { x: packet.org(i), y: packet.org(8 + i), z: packet.org(16 + i) },
                              Vec3 { x: packet.dir(i), y: packet.dir(8 + i), z: packet.dir(16 + i) },
                              v0, v1, v2, |t, u, v, mut mask| @{
                mask &= t < packet.tmax(i) & t > packet.tmin(i);
                id_mask_store(mask, id(tri), &packet.tri(i));
                real_mask_store(mask, t, &packet.tmax(i));
                real_mask_store(mask, u, &packet.u(i));
                real_mask_store(mask, v, &packet.v(i));
                continue()
            })
        }
    }
}

fn intersect_node(packet: &RayPacket, accel: Accel, node: i32, stack: &Stack) -> () {
    // Intersect the children of this node
    for min, max, push in iterate_children(accel, node, stack) {
        for i in vectorize(8, 0, 8) @{
            intersect_ray_box(Vec3 { x: packet.org(i), y: packet.org(8 + i), z: packet.org(16 + i) },
                              Vec3 { x: packet.inv(i), y: packet.inv(8 + i), z: packet.inv(16 + i) },
                              min, max, |t_entry, t_exit, mask| @{
                if any(mask & packet.tmin(i) < t_exit & packet.tmax(i) > t_entry) @{
                    push(t_entry)
                }
                continue()
            })
        }
    }
}

