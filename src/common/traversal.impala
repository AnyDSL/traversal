struct Ray {
    org: Vec3,
    tmin: f32,
    dir: Vec3,
    tmax: f32
}

struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

struct Vec4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32
}

struct BBox {
    lo_x: f32,
    hi_x: f32,
    lo_y: f32,
    hi_y: f32,
    lo_z: f32,
    hi_z: f32
}

struct Node {
    left_bb: BBox,
    right_bb: BBox,
    right: i32,
    left: i32,
    pad0: i32,
    pad1: i32
}

struct Hit {
    tri_id: i32,
    tmax: f32,
    pad0: i32,
    pad1: i32
}

struct Stack {
    data : [i32 * 64],
    id : i32
}

fn push(mut stack: &Stack, i: i32) -> () {
    stack.id++;
    stack.data(stack.id) = i;
}

fn pop(mut stack: &Stack) -> i32 {
    let ret = stack.data(stack.id);
    stack.id--;
    ret
}

static block_w = 32;
static block_h = 4;
static sentinel = 0x76543210u32;

extern "C" {
    fn fmin_fmin(f32, f32, f32) -> f32;
    fn fmax_fmax(f32, f32, f32) -> f32;
    fn fmin_fmax(f32, f32, f32) -> f32;
    fn fmax_fmin(f32, f32, f32) -> f32;

    fn magic_node_id(&[Node]) -> &[Node];
    fn magic_ray_id(&[Ray]) -> &[Ray];
    fn magic_tri_id(&[Vec4]) -> &[Vec4];
    fn magic_hit_id(&[Hit]) -> &[Hit];
}

fn fmax(a: f32, b: f32) -> f32 {
     if a > b {a} else {b}  
}

fn fmin(a: f32, b: f32) -> f32 {
     if a < b {a} else {b}  
}

fn span_begin(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32) -> f32 {
    fmax_fmax(fmin(a, b), fmin(c, d), fmin_fmax(e, f, g))
}

fn span_end(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32) -> f32 {
    fmin_fmin(fmax(a, b), fmax(c, d), fmax_fmin(e, f, g))
}

fn vec3(x: f32, y: f32, z: f32) -> Vec3 {
    Vec3 {
        x: x,
        y: y,
        z: z
    }
}

fn vec3_sub(a: Vec3, b: Vec3) -> Vec3 {
    vec3(a.x - b.x, a.y - b.y, a.z - b.z)
}

fn vec3_cross(a: Vec3, b: Vec3) -> Vec3 {
     vec3(a.y * b.z - a.z * b.y,
          a.z * b.x - a.x * b.z,
          a.x * b.y - a.y * b.x)
}

fn vec3_dot(a: Vec3, b: Vec3) -> f32 {
    a.x * b.x + a.y * b.y + a.z * b.z
}

extern fn traverse_accel(nodes_ptr: &[Node], rays_ptr: &[Ray], tris_ptr: &[Vec4], hits_ptr: &[Hit], ray_count: i32) -> () @{
    let dev = acc_dev();
    let grid = (ray_count / block_h, block_h, 1);
    let block = (block_w, block_h, 1);

    acc(dev, grid, block, |exit| {
        let nodes = magic_node_id(nodes_ptr);
        let rays = magic_ray_id(rays_ptr);
        let tris = magic_tri_id(tris_ptr);
        let mut hits = magic_hit_id(hits_ptr);

        let id = acc_tidx() + acc_bdimx() * (acc_tidy() + acc_bdimy() * (acc_bidx() + acc_gdimx() * acc_bidy()));
        if id > ray_count {
            exit()
        }

        // Initialize stack
        let mut stack : Stack;
        stack.id = 0;
        stack.data(0) = sentinel as i32;

        // Initialize ray
        let org_x = rays(id).org.x;
        let org_y = rays(id).org.y;
        let org_z = rays(id).org.z;
        let tmin = rays(id).tmin;

        let dir_x = rays(id).dir.x;
        let dir_y = rays(id).dir.y;
        let dir_z = rays(id).dir.z;
        let mut tmax = rays(id).tmax;

        let idir_x = 1.0f / dir_x;
        let idir_y = 1.0f / dir_y;
        let idir_z = 1.0f / dir_z;

        let mut node_id = 0;
        let mut tri_id = -1;

        // Traversal loop
        while (node_id as u32) < sentinel {
            // Load & intersect the node
            let node = nodes(node_id);

            let c0lox = (node.left_bb.lo_x - org_x) * idir_x;
            let c0hix = (node.left_bb.hi_x - org_x) * idir_x;
            let c0loy = (node.left_bb.lo_y - org_y) * idir_y;
            let c0hiy = (node.left_bb.hi_y - org_y) * idir_y;
            let c0loz = (node.left_bb.lo_z - org_z) * idir_z;
            let c0hiz = (node.left_bb.hi_z - org_z) * idir_z;
            let c0min = span_begin(c0lox, c0hix, c0loy, c0hiy, c0loz, c0hiz, tmin);
            let c0max = span_end(c0lox, c0hix, c0loy, c0hiy, c0loz, c0hiz, tmax);

            let c1lox = (node.right_bb.lo_x - org_x) * idir_x;
            let c1hix = (node.right_bb.hi_x - org_x) * idir_x;
            let c1loy = (node.right_bb.lo_y - org_y) * idir_y;
            let c1hiy = (node.right_bb.hi_y - org_y) * idir_y;
            let c1loz = (node.right_bb.lo_z - org_z) * idir_z;
            let c1hiz = (node.right_bb.hi_z - org_z) * idir_z;
            let c1min = span_begin(c1lox, c1hix, c1loy, c1hiy, c1loz, c1hiz, tmin);
            let c1max = span_end(c1lox, c1hix, c1loy, c1hiy, c1loz, c1hiz, tmax);

            let swp = c1min < c0min;
            let tc0 = c0max >= c0min;
            let tc1 = c1max >= c1min;

            if !tc0 && !tc1 {
                // Pop from the stack
                node_id = pop(&stack);
            } else {
                node_id = if tc0 { node.left } else { node.right };
                if tc0 && tc1 {
                    push(&stack, if swp { node_id = node.right; node.left } else { node.right });
                }
            }

            fn intersect_tri(id: i32, intr: fn (f32) -> ()) -> () {
                let v0 = vec3(tris(id + 0).x, tris(id + 0).y, tris(id + 0).z);
                let v1 = vec3(tris(id + 1).x, tris(id + 1).y, tris(id + 1).z);
                let v2 = vec3(tris(id + 2).x, tris(id + 2).y, tris(id + 2).z);

                let e0 = vec3_sub(v1, v0);
                let e1 = vec3_sub(v2, v0);
                let dir = vec3(dir_x, dir_y, dir_z);
                let pvec = vec3_cross(dir, e1);
                let det = vec3_dot(e0, pvec);
                let eps = 1e-4f;
                if fabsf(det) < eps {
                    return()
                }

                let idet = 1.0f / det;
                let org = vec3(org_x, org_y, org_z);
                let tvec = vec3_sub(org, v0);
                let u = vec3_dot(tvec, pvec) * idet;
                if u >= 0.0f && u <= 1.0f {
                    let qvec = vec3_cross(tvec, e0);                        
                    let v = vec3_dot(qvec, dir) * idet;
                    if v >= 0.0f && u + v <= 1.0f {
                        let t = vec3_dot(e1, qvec) * idet;
                        if t >= tmin && t <= tmax {
                            intr(t);
                        }
                    }
                }
            }

            // Intersect leaves
            while node_id < 0 {
                let mut loop_id = !node_id;

                while true {
                    @intersect_tri(loop_id, |t| {
                        tmax = t;
                        tri_id = loop_id;
                    });
                    loop_id += 3;
                    if tris(loop_id).x == -0.0f {
                        break()
                    }
                }

                // Pop node from the stack
                node_id = pop(&stack);
            }
        }

        if tri_id >= 0 {
            hits(id).tri_id = tri_id;
            hits(id).tmax = tmax;
        }
    })
}

