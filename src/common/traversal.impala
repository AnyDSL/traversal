struct Ray {
    org: Vec4,
    dir: Vec4
}

struct Vec4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32
}

extern fn traverse_accel(nodes: &[Node], rays: &[Ray], tris: &[Vec4], hits: &[Hit], ray_count: i32) -> () {
    for org, dir, tmin, tmax, record_hit in iterate_rays(rays, hits, ray_count) {
        // Allocate a stack for the traversal
        let stack = allocate_stack();

        // Initialize traversal variables
        let idir = vec3(real(1.0f) / dir.x, real(1.0f) / dir.y, real(1.0f) / dir.z);
        let mut t = tmax;
        let mut tri = intr(-1);            

        // Traversal loop
        while !stack.is_empty() {
            // Intersect children and update stack
            for min, max, hit in @iterate_children(nodes, stack.top(), stack) {
                intersect_ray_box(org, idir, tmin, t, min, max, |t0, t1| {
                    hit(t0 <= t1, t0)
                });
            }

            // Intersect leaves
            while is_leaf(nodes, stack.top()) {
                for id, v0, v1, v2 in iterate_triangles(nodes, stack.top(), tris) {
                    intersect_ray_tri(org, dir, tmin, t, v0, v1, v2, |mask, dist| {
                        mstore_real(mask, &t, dist);
                        mstore_intr(mask, &tri, id);
                    });
                }

                // Pop node from the stack
                stack.pop();
            }
        }

        record_hit(tri, t);
    }
}
