struct Ray {
    org: Vec4,
    dir: Vec4
}

struct Vec4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32
}

struct Hit {
    tri_id: i32,
    tmax: f32,
    u: f32,
    v: f32
}

extern fn traverse_accel(nodes: &[Node], rays: &[Ray], tris: &[Vec4], hits: &[Hit], ray_count: i32) -> () {
    for org, dir, tmin, tmax, record_hit in iterate_rays(rays, hits, ray_count) {
        // Allocate a stack for the traversal
        let stack = allocate_stack();

        // Initialize traversal variables
        let idir = vec3(safe_rcp(dir.x), safe_rcp(dir.y), safe_rcp(dir.z));
        let mut t = tmax;
        let mut u = real(0.0f);
        let mut v = real(0.0f);
        let mut tri = intr(-1);

        stack.push_top(0, tmin);

        // Traversal loop
        while !stack.is_empty() @{
            // Intersect children and update stack
            for min, max, hit in iterate_children(nodes, stack.top(), t, stack) {
                intersect_ray_box(org, idir, tmin, t, min, max, hit);
            }

            // Intersect leaves
            while is_leaf(stack.top()) {
                for id, v0, v1, v2 in iterate_triangles(nodes, stack.top(), tris) {
                    intersect_ray_tri(org, dir, tmin, t, v0, v1, v2, |mask, t0, u0, v0| {
                        t = select_real(mask, t0, t);
                        u = select_real(mask, u0, u);
                        v = select_real(mask, v0, v);
                        tri = select_intr(mask, id, tri);
                    });
                }

                // Pop node from the stack
                stack.pop();
            }
        }

        record_hit(tri, t, u, v);
    }
}
