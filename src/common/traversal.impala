struct Ray {
    org: Vec4,
    dir: Vec4
}

struct Vec4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32
}

struct Hit {
    tri_id: i32,
    tmax: f32,
    u: f32,
    v: f32
}

type RecordHitFn = fn (Intr, Real, Real, Real) -> ();
type BoxHitFn = fn (Real, Real) -> ();

type IterateRaysFn = fn (&[Ray], &[Hit], i32, fn (Vec3, Vec3, Real, Real, RecordHitFn) -> ()) -> ();
type IterateChildrenFn = fn (&[Node], Real, Stack, fn (Box, BoxHitFn) -> ()) -> ();
type IterateTrianglesFn = fn (&[Node], Real, Stack, &[Vec4], fn (Tri, Intr) -> ()) -> ();

fn traverse(iterate_rays: IterateRaysFn,
            iterate_children: IterateChildrenFn,
            iterate_triangles: IterateTrianglesFn,
            nodes: &[Node], tris: &[Vec4],
            rays: &[Ray], hits: &[Hit],
            ray_count: i32, occlusion: bool) -> () {
    for org, dir, tmin, tmax, record_hit in iterate_rays(rays, hits, ray_count) {
        // Allocate a stack for the traversal
        let stack = allocate_stack();

        // Initialize traversal variables
        let idir = vec3(safe_rcp(dir.x), safe_rcp(dir.y), safe_rcp(dir.z));
        let oidir = vec3_mul(idir, org);
        let mut t = tmax;
        let mut u = real(0.0f);
        let mut v = real(0.0f);
        let mut tri_id = intr(-1);

        stack.push_top(0, tmin);

        // Traversal loop
        while !stack.is_empty() {
            let terminate = break;

            // Intersect children and update stack
            for box, hit in iterate_children(nodes, t, stack) {
                intersect_ray_box(oidir, idir, tmin, t, box, hit);
            }

            // Intersect leaves
            while is_leaf(stack.top()) {
                for tri, id in iterate_triangles(nodes, t, stack, tris) {
                    intersect_ray_tri(org, dir, tmin, t, tri, |mask, t0, u0, v0| {
                        t = select_real(mask, t0, t);
                        u = select_real(mask, u0, u);
                        v = select_real(mask, v0, v);
                        tri_id = select_intr(mask, id, tri_id);

                        if occlusion && terminated(tri_id) {
                            terminate()
                        }
                    });
                }

                // Pop node from the stack
                stack.pop();
            }
        }

        record_hit(tri_id, t, u, v);
    }
}
