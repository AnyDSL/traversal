// Core part of the traversal algorithm
struct Rays {
    org_x: &[f32],
    org_y: &[f32],
    org_z: &[f32],

    dir_x: &[f32],
    dir_y: &[f32],
    dir_z: &[f32],

    tri: &[i32],
    tmin: &[f32],
    tmax: &[f32],
    u: &[f32],
    v: &[f32]
}

extern fn traverse_accel(accel_ptr: &Accel, rays_ptr: &Rays, ray_count: i32) -> () @{
    let accel = *accel_ptr;
    let rays = *rays_ptr;

    for ray in iterate_rays(rays, 0, ray_count) @{
        let mut stack = empty_stack();
        let mut postponed = empty_stack();

        push_node(&stack, root_node(accel));
        while !is_empty(&stack) {
            let id = pop_node(&stack);

            if @is_leaf(accel, id) {
                if postpone_count > 0 @{
                    push_node(&postponed, id)
                } else @{
                    intersect_leaf(ray, accel, id)
                }
            } else @{
                intersect_node(ray, accel, id, &stack);
            }

            if postpone_count > 0 @{
                if stack_size(&postponed) >= postpone_count @{
                    while !is_empty(&postponed) @{
                        let id = pop_node(&postponed);
                        intersect_leaf(ray, accel, id)
                    }
                }
            }
        }

        if postpone_count > 0 @{
            while !is_empty(&postponed) @{
                let id = pop_node(&postponed);
                intersect_leaf(ray, accel, id)
            }
        }
    }
}

