struct Ray {
    org: Vec3,
    tmin: f32,
    dir: Vec3,
    tmax: f32
}

struct Vec3 {
    x: f32,
    y: f32,
    z: f32
}

struct Vec4 {
    x: f32,
    y: f32,
    z: f32,
    w: f32
}

struct BBox {
    lo_x: f32,
    hi_x: f32,
    lo_y: f32,
    hi_y: f32,
    lo_z: f32,
    hi_z: f32
}

struct Node {
    left_bb: BBox,
    right_bb: BBox,
    left: i32,
    right: i32,
    pad0: i32,
    pad1: i32
}

struct Hit {
    tri_id: i32,
    tmax: f32,
    pad0: i32,
    pad1: i32
}

struct Stack {
    data : [i32 * 64],
    id : i32
}

fn empty_stack() -> Stack {
    let mut stack : Stack;
    stack.data(0) = stack_sentinel as i32;
    stack.id = 0;
    stack
}

fn push(mut stack: &Stack, i: i32) -> () {
    stack.id++;
    stack.data(stack.id) = i;
}

fn pop(mut stack: &Stack) -> i32 {
    let ret = stack.data(stack.id);
    stack.id--;
    ret
}

static block_w = 32;
static block_h = 4;
static stack_sentinel = 0x76543210u32;

extern "C" {
    fn fmin_fmin(f32, f32, f32) -> f32;
    fn fmax_fmax(f32, f32, f32) -> f32;
    fn fmin_fmax(f32, f32, f32) -> f32;
    fn fmax_fmin(f32, f32, f32) -> f32;

    fn magic_node_id(&[Node]) -> &[Node];
    fn magic_ray_id(&[Ray]) -> &[Ray];
    fn magic_tri_id(&[Vec4]) -> &[Vec4];
    fn magic_hit_id(&[Hit]) -> &[Hit];
}

fn fmax(a: f32, b: f32) -> f32 {
     if a > b {a} else {b}  
}

fn fmin(a: f32, b: f32) -> f32 {
     if a < b {a} else {b}  
}

fn span_begin(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32) -> f32 {
    fmax_fmax(fmin(a, b), fmin(c, d), fmin_fmax(e, f, g))
}

fn span_end(a: f32, b: f32, c: f32, d: f32, e: f32, f: f32, g: f32) -> f32 {
    fmin_fmin(fmax(a, b), fmax(c, d), fmax_fmin(e, f, g))
}

fn vec3(x: f32, y: f32, z: f32) -> Vec3 {
    Vec3 {
        x: x,
        y: y,
        z: z
    }
}

fn vec3_sub(a: Vec3, b: Vec3) -> Vec3 {
    vec3(a.x - b.x, a.y - b.y, a.z - b.z)
}

fn vec3_cross(a: Vec3, b: Vec3) -> Vec3 {
     vec3(a.y * b.z - a.z * b.y,
          a.z * b.x - a.x * b.z,
          a.x * b.y - a.y * b.x)
}

fn vec3_dot(a: Vec3, b: Vec3) -> f32 {
    a.x * b.x + a.y * b.y + a.z * b.z
}

struct RayData {
    org: Vec3,
    dir: Vec3,
    idir: Vec3,
    tmin: f32,
    tmax: f32,
    tri_id: i32
}

fn intersect_ray_box(org: Vec3, idir: Vec3, tmin: f32, tmax: f32, min: Vec3, max: Vec3, intr: fn (f32, f32) -> ()) -> () {
    let t0_x = (min.x - org.x) * idir.x;
    let t1_x = (max.x - org.x) * idir.x;
    let t0_y = (min.y - org.y) * idir.y;
    let t1_y = (max.y - org.y) * idir.y;
    let t0_z = (min.z - org.z) * idir.z;
    let t1_z = (max.z - org.z) * idir.z;
    let t0 = span_begin(t0_x, t1_x, t0_y, t1_y, t0_z, t1_z, tmin);
    let t1 = span_end(t0_x, t1_x, t0_y, t1_y, t0_z, t1_z, tmax);
    intr(t0, t1)
}

fn intersect_ray_tri(org: Vec3, dir: Vec3, tmin: f32, tmax: f32, v0: Vec3, v1: Vec3, v2: Vec3, intr: fn (f32) -> ()) -> () {
    let e0 = vec3_sub(v1, v0);
    let e1 = vec3_sub(v2, v0);
    let pvec = vec3_cross(dir, e1);
    let det = vec3_dot(e0, pvec);
    let eps = 1e-4f;
    if fabsf(det) < eps {
        return()
    }

    let idet = 1.0f / det;
    let tvec = vec3_sub(org, v0);
    let u = vec3_dot(tvec, pvec) * idet;
    if u >= 0.0f && u <= 1.0f {
        let qvec = vec3_cross(tvec, e0);                        
        let v = vec3_dot(qvec, dir) * idet;
        if v >= 0.0f && u + v <= 1.0f {
            let t = vec3_dot(e1, qvec) * idet;
            if t >= tmin && t <= tmax {
                intr(t);
            }
        }
    }
}

fn iterate_triangles(nodes: &[Node], mut tris: &[Vec4], node_id: i32, body: fn (i32, Vec3, Vec3, Vec3) -> ()) -> () {
    let mut loop_id = !node_id;
    while true {
        let v0 = *(&tris(loop_id + 0) as &simd[f32 * 4]);
        let v1 = *(&tris(loop_id + 1) as &simd[f32 * 4]);
        let v2 = *(&tris(loop_id + 2) as &simd[f32 * 4]);

        body(loop_id,
             vec3(v0(0), v0(1), v0(2)),
             vec3(v1(0), v1(1), v1(2)),
             vec3(v2(0), v2(1), v2(2)));

        loop_id += 3;
        if tris(loop_id).x == -0.0f {
            break()
        }
    }
}

fn iterate_children(mut nodes: &[Node], stack: &Stack, mut node_id: &i32, body: fn(Vec3, Vec3, fn (bool, f32) -> ()) -> ()) -> () {
    let mut node_ptr = &nodes(*node_id) as &[f32];
    let bb0 = *(&node_ptr(0) as &simd[f32 * 4]);
    let bb1 = *(&node_ptr(4) as &simd[f32 * 4]);
    let bb2 = *(&node_ptr(8) as &simd[f32 * 4]);
    let children = *(&node_ptr(12) as &simd[i32 * 4]);

    let mut t : [f32 * 2];
    let mut next : [i32 * 2];
    let mut intr : [bool * 2] = [false, false];

    body(vec3(bb0(0), bb0(2), bb1(0)), vec3(bb0(1), bb0(3), bb1(1)), |hit, t0| {
        t(0) = t0;
        next(0) = children(0);
        intr(0) = hit;
    });

    body(vec3(bb1(2), bb2(0), bb2(2)), vec3(bb1(3), bb2(1), bb2(3)), |hit, t0| {
        t(1) = t0;
        next(1) = children(1);
        intr(1) = hit;
    });

    if !intr(0) && !intr(1) {
        // Pop from the stack
        *node_id = pop(stack);
    } else {
        *node_id = if intr(0) { next(0) } else { next(1) };
        if intr(0) && intr(1) {
            push(stack, if t(1) < t(0) { *node_id = next(1); next(0) } else { next(1) });
        }
    }
}

extern fn traverse_accel(nodes_ptr: &[Node], rays_ptr: &[Ray], tris_ptr: &[Vec4], hits_ptr: &[Hit], ray_count: i32) -> () @{
    let dev = acc_dev();
    let grid = (ray_count / block_h, block_h, 1);
    let block = (block_w, block_h, 1);

    acc(dev, grid, block, |exit| @{
        let mut rays = magic_ray_id(rays_ptr);
        let mut hits = magic_hit_id(hits_ptr);
        let nodes = magic_node_id(nodes_ptr);
        let tris = magic_tri_id(tris_ptr);

        let id = acc_tidx() + acc_bdimx() * (acc_tidy() + acc_bdimy() * (acc_bidx() + acc_gdimx() * acc_bidy()));
        if id > ray_count {
            exit()
        }

        // Initialize stack
        let mut stack : Stack;
        stack.id = 0;
        stack.data(0) = stack_sentinel as i32;

        // Load ray
        let mut ray_ptr = &rays(id) as &[f32];
        let ray0 = *(&ray_ptr(0) as &simd[f32 * 4]);
        let ray1 = *(&ray_ptr(4) as &simd[f32 * 4]);

        let org = vec3(ray0(0), ray0(1), ray0(2));
        let dir = vec3(ray1(0), ray1(1), ray1(2));
        let idir = vec3(1.0f / ray1(0), 1.0f / ray1(1), 1.0f / ray1(2));
        let tmin = ray0(3);
        let mut tmax = ray1(3);
        let mut tri_id = -1;
        let mut node_id = 0;

        // Traversal loop
        while (node_id as u32) < stack_sentinel {
            // Intersect children
            for min, max, hit in iterate_children(nodes, &stack, &node_id) @{
                intersect_ray_box(org, idir, tmin, tmax, min, max, |t0, t1| @{
                    hit(t0 <= t1, t0)
                });
            }

            // Intersect leaves
            while node_id < 0 {
                for id, v0, v1, v2 in iterate_triangles(nodes, tris, node_id) @{
                    intersect_ray_tri(org, dir, tmin, tmax, v0, v1, v2, |t| {
                        tmax = t;
                        tri_id = id;
                    });
                }

                // Pop node from the stack
                node_id = pop(&stack);
            }
        }

        if tri_id >= 0 {
            hits(id).tri_id = tri_id;
            hits(id).tmax = tmax;
        }
    })
}

